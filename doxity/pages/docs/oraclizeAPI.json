{"fileName":"/contracts/oraclize/oraclizeAPI.sol","name":"oraclizeAPI","abi":[{"constant":false,"inputs":[{"name":"myid","type":"bytes32"},{"name":"result","type":"string"}],"name":"__callback","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"myid","type":"bytes32"},{"name":"result","type":"string"},{"name":"proof","type":"bytes"}],"name":"__callback","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"}],"bin":"6060604052341561000f57600080fd5b6101cb8061001e6000396000f30060606040526004361061004c576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff16806327dc297e1461005157806338bbfa50146100bb575b600080fd5b341561005c57600080fd5b6100b960048080356000191690602001909190803590602001908201803590602001908080601f01602080910402602001604051908101604052809392919081815260200183838082843782019150505050505091905050610168565b005b34156100c657600080fd5b61016660048080356000191690602001909190803590602001908201803590602001908080601f0160208091040260200160405190810160405280939291908181526020018383808284378201915050505050509190803590602001908201803590602001908080601f0160208091040260200160405190810160405280939291908181526020018383808284378201915050505050509190505061019a565b005b6101968282600060405180591061017c5750595b9080825280601f01601f191660200182016040525061019a565b5050565b5050505600a165627a7a72305820e8cf2c3cae582f936966ebeb2183e0fde185c719e4d8355d0d06ada1fa926daa0029","opcodes":"PUSH1 0x60 PUSH1 0x40 MSTORE CALLVALUE ISZERO PUSH2 0xF JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH2 0x1CB DUP1 PUSH2 0x1E PUSH1 0x0 CODECOPY PUSH1 0x0 RETURN STOP PUSH1 0x60 PUSH1 0x40 MSTORE PUSH1 0x4 CALLDATASIZE LT PUSH2 0x4C JUMPI PUSH1 0x0 CALLDATALOAD PUSH29 0x100000000000000000000000000000000000000000000000000000000 SWAP1 DIV PUSH4 0xFFFFFFFF AND DUP1 PUSH4 0x27DC297E EQ PUSH2 0x51 JUMPI DUP1 PUSH4 0x38BBFA50 EQ PUSH2 0xBB JUMPI JUMPDEST PUSH1 0x0 DUP1 REVERT JUMPDEST CALLVALUE ISZERO PUSH2 0x5C JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH2 0xB9 PUSH1 0x4 DUP1 DUP1 CALLDATALOAD PUSH1 0x0 NOT AND SWAP1 PUSH1 0x20 ADD SWAP1 SWAP2 SWAP1 DUP1 CALLDATALOAD SWAP1 PUSH1 0x20 ADD SWAP1 DUP3 ADD DUP1 CALLDATALOAD SWAP1 PUSH1 0x20 ADD SWAP1 DUP1 DUP1 PUSH1 0x1F ADD PUSH1 0x20 DUP1 SWAP2 DIV MUL PUSH1 0x20 ADD PUSH1 0x40 MLOAD SWAP1 DUP2 ADD PUSH1 0x40 MSTORE DUP1 SWAP4 SWAP3 SWAP2 SWAP1 DUP2 DUP2 MSTORE PUSH1 0x20 ADD DUP4 DUP4 DUP1 DUP3 DUP5 CALLDATACOPY DUP3 ADD SWAP2 POP POP POP POP POP POP SWAP2 SWAP1 POP POP PUSH2 0x168 JUMP JUMPDEST STOP JUMPDEST CALLVALUE ISZERO PUSH2 0xC6 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH2 0x166 PUSH1 0x4 DUP1 DUP1 CALLDATALOAD PUSH1 0x0 NOT AND SWAP1 PUSH1 0x20 ADD SWAP1 SWAP2 SWAP1 DUP1 CALLDATALOAD SWAP1 PUSH1 0x20 ADD SWAP1 DUP3 ADD DUP1 CALLDATALOAD SWAP1 PUSH1 0x20 ADD SWAP1 DUP1 DUP1 PUSH1 0x1F ADD PUSH1 0x20 DUP1 SWAP2 DIV MUL PUSH1 0x20 ADD PUSH1 0x40 MLOAD SWAP1 DUP2 ADD PUSH1 0x40 MSTORE DUP1 SWAP4 SWAP3 SWAP2 SWAP1 DUP2 DUP2 MSTORE PUSH1 0x20 ADD DUP4 DUP4 DUP1 DUP3 DUP5 CALLDATACOPY DUP3 ADD SWAP2 POP POP POP POP POP POP SWAP2 SWAP1 DUP1 CALLDATALOAD SWAP1 PUSH1 0x20 ADD SWAP1 DUP3 ADD DUP1 CALLDATALOAD SWAP1 PUSH1 0x20 ADD SWAP1 DUP1 DUP1 PUSH1 0x1F ADD PUSH1 0x20 DUP1 SWAP2 DIV MUL PUSH1 0x20 ADD PUSH1 0x40 MLOAD SWAP1 DUP2 ADD PUSH1 0x40 MSTORE DUP1 SWAP4 SWAP3 SWAP2 SWAP1 DUP2 DUP2 MSTORE PUSH1 0x20 ADD DUP4 DUP4 DUP1 DUP3 DUP5 CALLDATACOPY DUP3 ADD SWAP2 POP POP POP POP POP POP SWAP2 SWAP1 POP POP PUSH2 0x19A JUMP JUMPDEST STOP JUMPDEST PUSH2 0x196 DUP3 DUP3 PUSH1 0x0 PUSH1 0x40 MLOAD DUP1 MSIZE LT PUSH2 0x17C JUMPI POP MSIZE JUMPDEST SWAP1 DUP1 DUP3 MSTORE DUP1 PUSH1 0x1F ADD PUSH1 0x1F NOT AND PUSH1 0x20 ADD DUP3 ADD PUSH1 0x40 MSTORE POP PUSH2 0x19A JUMP JUMPDEST POP POP JUMP JUMPDEST POP POP POP JUMP STOP LOG1 PUSH6 0x627A7A723058 KECCAK256 0xe8 0xcf 0x2c EXTCODECOPY 0xae PC 0x2f SWAP4 PUSH10 0x66EBEB2183E0FDE185C7 NOT 0xe4 0xd8 CALLDATALOAD 0x5d 0xd MOD 0xad LOG1 STATICCALL SWAP3 PUSH14 0xAA00290000000000000000000000 ","source":"pragma solidity ^0.4.11;\n// <ORACLIZE_API>\n/*\nCopyright (c) 2015-2016 Oraclize SRL\nCopyright (c) 2016 Oraclize LTD\n\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\n\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\n\ncontract OraclizeI {\n\taddress public cbAddress;\n\tfunction query(uint _timestamp, string _datasource, string _arg) payable returns (bytes32 _id);\n\tfunction query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) payable returns (bytes32 _id);\n\tfunction query2(uint _timestamp, string _datasource, string _arg1, string _arg2) payable returns (bytes32 _id);\n\tfunction query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) payable returns (bytes32 _id);\n\tfunction queryN(uint _timestamp, string _datasource, bytes _argN) payable returns (bytes32 _id);\n\tfunction queryN_withGasLimit(uint _timestamp, string _datasource, bytes _argN, uint _gaslimit) payable returns (bytes32 _id);\n\tfunction getPrice(string _datasource) returns (uint _dsprice);\n\tfunction getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\n\tfunction useCoupon(string _coupon);\n\tfunction setProofType(byte _proofType);\n\tfunction setConfig(bytes32 _config);\n\tfunction setCustomGasPrice(uint _gasPrice);\n\tfunction randomDS_getSessionPubKeyHash() returns(bytes32);\n}\ncontract OraclizeAddrResolverI {\n\tfunction getAddress() returns (address _addr);\n}\ncontract usingOraclize {\n\tuint constant day = 60*60*24;\n\tuint constant week = 60*60*24*7;\n\tuint constant month = 60*60*24*30;\n\tbyte constant proofType_NONE = 0x00;\n\tbyte constant proofType_TLSNotary = 0x10;\n\tbyte constant proofType_Android = 0x20;\n\tbyte constant proofType_Ledger = 0x30;\n\tbyte constant proofType_Native = 0xF0;\n\tbyte constant proofStorage_IPFS = 0x01;\n\tuint8 constant networkID_auto = 0;\n\tuint8 constant networkID_mainnet = 1;\n\tuint8 constant networkID_testnet = 2;\n\tuint8 constant networkID_morden = 2;\n\tuint8 constant networkID_consensys = 161;\n\n\tOraclizeAddrResolverI OAR;\n\n\tOraclizeI oraclize;\n\tmodifier oraclizeAPI {\n\t\tif((address(OAR)==0)||(getCodeSize(address(OAR))==0))\n\t\toraclize_setNetwork(networkID_auto);\n\n\t\tif(address(oraclize) != OAR.getAddress())\n\t\toraclize = OraclizeI(OAR.getAddress());\n\n\t\t_;\n\t}\n\tmodifier coupon(string code){\n\t\toraclize = OraclizeI(OAR.getAddress());\n\t\toraclize.useCoupon(code);\n\t\t_;\n\t}\n\n\tfunction oraclize_setNetwork(uint8 networkID) internal returns(bool){\n\t\tif (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){ //mainnet\n\t\t\tOAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);\n\t\t\toraclize_setNetworkName(\"eth_mainnet\");\n\t\t\treturn true;\n\t\t}\n\t\tif (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){ //ropsten testnet\n\t\t\tOAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);\n\t\t\toraclize_setNetworkName(\"eth_ropsten3\");\n\t\t\treturn true;\n\t\t}\n\t\tif (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){ //kovan testnet\n\t\t\tOAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);\n\t\t\toraclize_setNetworkName(\"eth_kovan\");\n\t\t\treturn true;\n\t\t}\n\t\tif (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){ //rinkeby testnet\n\t\t\tOAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);\n\t\t\toraclize_setNetworkName(\"eth_rinkeby\");\n\t\t\treturn true;\n\t\t}\n\t\tif (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){ //ethereum-bridge\n\t\t\tOAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);\n\t\t\treturn true;\n\t\t}\n\t\tif (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){ //ether.camp ide\n\t\t\tOAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);\n\t\t\treturn true;\n\t\t}\n\t\tif (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){ //browser-solidity\n\t\t\tOAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction __callback(bytes32 myid, string result) {\n\t\t__callback(myid, result, new bytes(0));\n\t}\n\tfunction __callback(bytes32 myid, string result, bytes proof) {\n\t}\n\n\tfunction oraclize_useCoupon(string code) oraclizeAPI internal {\n\t\toraclize.useCoupon(code);\n\t}\n\n\tfunction oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){\n\t\treturn oraclize.getPrice(datasource);\n\t}\n\n\tfunction oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){\n\t\treturn oraclize.getPrice(datasource, gaslimit);\n\t}\n\n\tfunction oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n\t\tuint price = oraclize.getPrice(datasource);\n\t\tif (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n\t\treturn oraclize.query.value(price)(0, datasource, arg);\n\t}\n\tfunction oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n\t\tuint price = oraclize.getPrice(datasource);\n\t\tif (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n\t\treturn oraclize.query.value(price)(timestamp, datasource, arg);\n\t}\n\tfunction oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n\t\tuint price = oraclize.getPrice(datasource, gaslimit);\n\t\tif (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n\t\treturn oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\n\t}\n\tfunction oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n\t\tuint price = oraclize.getPrice(datasource, gaslimit);\n\t\tif (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n\t\treturn oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\n\t}\n\tfunction oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n\t\tuint price = oraclize.getPrice(datasource);\n\t\tif (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n\t\treturn oraclize.query2.value(price)(0, datasource, arg1, arg2);\n\t}\n\tfunction oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n\t\tuint price = oraclize.getPrice(datasource);\n\t\tif (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n\t\treturn oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\n\t}\n\tfunction oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n\t\tuint price = oraclize.getPrice(datasource, gaslimit);\n\t\tif (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n\t\treturn oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\n\t}\n\tfunction oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n\t\tuint price = oraclize.getPrice(datasource, gaslimit);\n\t\tif (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n\t\treturn oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\n\t}\n\tfunction oraclize_query(string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n\t\tuint price = oraclize.getPrice(datasource);\n\t\tif (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n\t\tbytes memory args = stra2cbor(argN);\n\t\treturn oraclize.queryN.value(price)(0, datasource, args);\n\t}\n\tfunction oraclize_query(uint timestamp, string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n\t\tuint price = oraclize.getPrice(datasource);\n\t\tif (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n\t\tbytes memory args = stra2cbor(argN);\n\t\treturn oraclize.queryN.value(price)(timestamp, datasource, args);\n\t}\n\tfunction oraclize_query(uint timestamp, string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n\t\tuint price = oraclize.getPrice(datasource, gaslimit);\n\t\tif (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n\t\tbytes memory args = stra2cbor(argN);\n\t\treturn oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\n\t}\n\tfunction oraclize_query(string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n\t\tuint price = oraclize.getPrice(datasource, gaslimit);\n\t\tif (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n\t\tbytes memory args = stra2cbor(argN);\n\t\treturn oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\n\t}\n\tfunction oraclize_query(string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\n\t\tstring[] memory dynargs = new string[](1);\n\t\tdynargs[0] = args[0];\n\t\treturn oraclize_query(datasource, dynargs);\n\t}\n\tfunction oraclize_query(uint timestamp, string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\n\t\tstring[] memory dynargs = new string[](1);\n\t\tdynargs[0] = args[0];\n\t\treturn oraclize_query(timestamp, datasource, dynargs);\n\t}\n\tfunction oraclize_query(uint timestamp, string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\t\tstring[] memory dynargs = new string[](1);\n\t\tdynargs[0] = args[0];\n\t\treturn oraclize_query(timestamp, datasource, dynargs, gaslimit);\n\t}\n\tfunction oraclize_query(string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\t\tstring[] memory dynargs = new string[](1);\n\t\tdynargs[0] = args[0];\n\t\treturn oraclize_query(datasource, dynargs, gaslimit);\n\t}\n\n\tfunction oraclize_query(string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\n\t\tstring[] memory dynargs = new string[](2);\n\t\tdynargs[0] = args[0];\n\t\tdynargs[1] = args[1];\n\t\treturn oraclize_query(datasource, dynargs);\n\t}\n\tfunction oraclize_query(uint timestamp, string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\n\t\tstring[] memory dynargs = new string[](2);\n\t\tdynargs[0] = args[0];\n\t\tdynargs[1] = args[1];\n\t\treturn oraclize_query(timestamp, datasource, dynargs);\n\t}\n\tfunction oraclize_query(uint timestamp, string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\t\tstring[] memory dynargs = new string[](2);\n\t\tdynargs[0] = args[0];\n\t\tdynargs[1] = args[1];\n\t\treturn oraclize_query(timestamp, datasource, dynargs, gaslimit);\n\t}\n\tfunction oraclize_query(string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\t\tstring[] memory dynargs = new string[](2);\n\t\tdynargs[0] = args[0];\n\t\tdynargs[1] = args[1];\n\t\treturn oraclize_query(datasource, dynargs, gaslimit);\n\t}\n\tfunction oraclize_query(string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\n\t\tstring[] memory dynargs = new string[](3);\n\t\tdynargs[0] = args[0];\n\t\tdynargs[1] = args[1];\n\t\tdynargs[2] = args[2];\n\t\treturn oraclize_query(datasource, dynargs);\n\t}\n\tfunction oraclize_query(uint timestamp, string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\n\t\tstring[] memory dynargs = new string[](3);\n\t\tdynargs[0] = args[0];\n\t\tdynargs[1] = args[1];\n\t\tdynargs[2] = args[2];\n\t\treturn oraclize_query(timestamp, datasource, dynargs);\n\t}\n\tfunction oraclize_query(uint timestamp, string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\t\tstring[] memory dynargs = new string[](3);\n\t\tdynargs[0] = args[0];\n\t\tdynargs[1] = args[1];\n\t\tdynargs[2] = args[2];\n\t\treturn oraclize_query(timestamp, datasource, dynargs, gaslimit);\n\t}\n\tfunction oraclize_query(string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\t\tstring[] memory dynargs = new string[](3);\n\t\tdynargs[0] = args[0];\n\t\tdynargs[1] = args[1];\n\t\tdynargs[2] = args[2];\n\t\treturn oraclize_query(datasource, dynargs, gaslimit);\n\t}\n\n\tfunction oraclize_query(string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\n\t\tstring[] memory dynargs = new string[](4);\n\t\tdynargs[0] = args[0];\n\t\tdynargs[1] = args[1];\n\t\tdynargs[2] = args[2];\n\t\tdynargs[3] = args[3];\n\t\treturn oraclize_query(datasource, dynargs);\n\t}\n\tfunction oraclize_query(uint timestamp, string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\n\t\tstring[] memory dynargs = new string[](4);\n\t\tdynargs[0] = args[0];\n\t\tdynargs[1] = args[1];\n\t\tdynargs[2] = args[2];\n\t\tdynargs[3] = args[3];\n\t\treturn oraclize_query(timestamp, datasource, dynargs);\n\t}\n\tfunction oraclize_query(uint timestamp, string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\t\tstring[] memory dynargs = new string[](4);\n\t\tdynargs[0] = args[0];\n\t\tdynargs[1] = args[1];\n\t\tdynargs[2] = args[2];\n\t\tdynargs[3] = args[3];\n\t\treturn oraclize_query(timestamp, datasource, dynargs, gaslimit);\n\t}\n\tfunction oraclize_query(string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\t\tstring[] memory dynargs = new string[](4);\n\t\tdynargs[0] = args[0];\n\t\tdynargs[1] = args[1];\n\t\tdynargs[2] = args[2];\n\t\tdynargs[3] = args[3];\n\t\treturn oraclize_query(datasource, dynargs, gaslimit);\n\t}\n\tfunction oraclize_query(string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\n\t\tstring[] memory dynargs = new string[](5);\n\t\tdynargs[0] = args[0];\n\t\tdynargs[1] = args[1];\n\t\tdynargs[2] = args[2];\n\t\tdynargs[3] = args[3];\n\t\tdynargs[4] = args[4];\n\t\treturn oraclize_query(datasource, dynargs);\n\t}\n\tfunction oraclize_query(uint timestamp, string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\n\t\tstring[] memory dynargs = new string[](5);\n\t\tdynargs[0] = args[0];\n\t\tdynargs[1] = args[1];\n\t\tdynargs[2] = args[2];\n\t\tdynargs[3] = args[3];\n\t\tdynargs[4] = args[4];\n\t\treturn oraclize_query(timestamp, datasource, dynargs);\n\t}\n\tfunction oraclize_query(uint timestamp, string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\t\tstring[] memory dynargs = new string[](5);\n\t\tdynargs[0] = args[0];\n\t\tdynargs[1] = args[1];\n\t\tdynargs[2] = args[2];\n\t\tdynargs[3] = args[3];\n\t\tdynargs[4] = args[4];\n\t\treturn oraclize_query(timestamp, datasource, dynargs, gaslimit);\n\t}\n\tfunction oraclize_query(string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\t\tstring[] memory dynargs = new string[](5);\n\t\tdynargs[0] = args[0];\n\t\tdynargs[1] = args[1];\n\t\tdynargs[2] = args[2];\n\t\tdynargs[3] = args[3];\n\t\tdynargs[4] = args[4];\n\t\treturn oraclize_query(datasource, dynargs, gaslimit);\n\t}\n\tfunction oraclize_query(string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n\t\tuint price = oraclize.getPrice(datasource);\n\t\tif (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n\t\tbytes memory args = ba2cbor(argN);\n\t\treturn oraclize.queryN.value(price)(0, datasource, args);\n\t}\n\tfunction oraclize_query(uint timestamp, string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n\t\tuint price = oraclize.getPrice(datasource);\n\t\tif (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n\t\tbytes memory args = ba2cbor(argN);\n\t\treturn oraclize.queryN.value(price)(timestamp, datasource, args);\n\t}\n\tfunction oraclize_query(uint timestamp, string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n\t\tuint price = oraclize.getPrice(datasource, gaslimit);\n\t\tif (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n\t\tbytes memory args = ba2cbor(argN);\n\t\treturn oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\n\t}\n\tfunction oraclize_query(string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n\t\tuint price = oraclize.getPrice(datasource, gaslimit);\n\t\tif (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n\t\tbytes memory args = ba2cbor(argN);\n\t\treturn oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\n\t}\n\tfunction oraclize_query(string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\n\t\tbytes[] memory dynargs = new bytes[](1);\n\t\tdynargs[0] = args[0];\n\t\treturn oraclize_query(datasource, dynargs);\n\t}\n\tfunction oraclize_query(uint timestamp, string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\n\t\tbytes[] memory dynargs = new bytes[](1);\n\t\tdynargs[0] = args[0];\n\t\treturn oraclize_query(timestamp, datasource, dynargs);\n\t}\n\tfunction oraclize_query(uint timestamp, string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\t\tbytes[] memory dynargs = new bytes[](1);\n\t\tdynargs[0] = args[0];\n\t\treturn oraclize_query(timestamp, datasource, dynargs, gaslimit);\n\t}\n\tfunction oraclize_query(string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\t\tbytes[] memory dynargs = new bytes[](1);\n\t\tdynargs[0] = args[0];\n\t\treturn oraclize_query(datasource, dynargs, gaslimit);\n\t}\n\n\tfunction oraclize_query(string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\n\t\tbytes[] memory dynargs = new bytes[](2);\n\t\tdynargs[0] = args[0];\n\t\tdynargs[1] = args[1];\n\t\treturn oraclize_query(datasource, dynargs);\n\t}\n\tfunction oraclize_query(uint timestamp, string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\n\t\tbytes[] memory dynargs = new bytes[](2);\n\t\tdynargs[0] = args[0];\n\t\tdynargs[1] = args[1];\n\t\treturn oraclize_query(timestamp, datasource, dynargs);\n\t}\n\tfunction oraclize_query(uint timestamp, string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\t\tbytes[] memory dynargs = new bytes[](2);\n\t\tdynargs[0] = args[0];\n\t\tdynargs[1] = args[1];\n\t\treturn oraclize_query(timestamp, datasource, dynargs, gaslimit);\n\t}\n\tfunction oraclize_query(string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\t\tbytes[] memory dynargs = new bytes[](2);\n\t\tdynargs[0] = args[0];\n\t\tdynargs[1] = args[1];\n\t\treturn oraclize_query(datasource, dynargs, gaslimit);\n\t}\n\tfunction oraclize_query(string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\n\t\tbytes[] memory dynargs = new bytes[](3);\n\t\tdynargs[0] = args[0];\n\t\tdynargs[1] = args[1];\n\t\tdynargs[2] = args[2];\n\t\treturn oraclize_query(datasource, dynargs);\n\t}\n\tfunction oraclize_query(uint timestamp, string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\n\t\tbytes[] memory dynargs = new bytes[](3);\n\t\tdynargs[0] = args[0];\n\t\tdynargs[1] = args[1];\n\t\tdynargs[2] = args[2];\n\t\treturn oraclize_query(timestamp, datasource, dynargs);\n\t}\n\tfunction oraclize_query(uint timestamp, string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\t\tbytes[] memory dynargs = new bytes[](3);\n\t\tdynargs[0] = args[0];\n\t\tdynargs[1] = args[1];\n\t\tdynargs[2] = args[2];\n\t\treturn oraclize_query(timestamp, datasource, dynargs, gaslimit);\n\t}\n\tfunction oraclize_query(string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\t\tbytes[] memory dynargs = new bytes[](3);\n\t\tdynargs[0] = args[0];\n\t\tdynargs[1] = args[1];\n\t\tdynargs[2] = args[2];\n\t\treturn oraclize_query(datasource, dynargs, gaslimit);\n\t}\n\n\tfunction oraclize_query(string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\n\t\tbytes[] memory dynargs = new bytes[](4);\n\t\tdynargs[0] = args[0];\n\t\tdynargs[1] = args[1];\n\t\tdynargs[2] = args[2];\n\t\tdynargs[3] = args[3];\n\t\treturn oraclize_query(datasource, dynargs);\n\t}\n\tfunction oraclize_query(uint timestamp, string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\n\t\tbytes[] memory dynargs = new bytes[](4);\n\t\tdynargs[0] = args[0];\n\t\tdynargs[1] = args[1];\n\t\tdynargs[2] = args[2];\n\t\tdynargs[3] = args[3];\n\t\treturn oraclize_query(timestamp, datasource, dynargs);\n\t}\n\tfunction oraclize_query(uint timestamp, string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\t\tbytes[] memory dynargs = new bytes[](4);\n\t\tdynargs[0] = args[0];\n\t\tdynargs[1] = args[1];\n\t\tdynargs[2] = args[2];\n\t\tdynargs[3] = args[3];\n\t\treturn oraclize_query(timestamp, datasource, dynargs, gaslimit);\n\t}\n\tfunction oraclize_query(string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\t\tbytes[] memory dynargs = new bytes[](4);\n\t\tdynargs[0] = args[0];\n\t\tdynargs[1] = args[1];\n\t\tdynargs[2] = args[2];\n\t\tdynargs[3] = args[3];\n\t\treturn oraclize_query(datasource, dynargs, gaslimit);\n\t}\n\tfunction oraclize_query(string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\n\t\tbytes[] memory dynargs = new bytes[](5);\n\t\tdynargs[0] = args[0];\n\t\tdynargs[1] = args[1];\n\t\tdynargs[2] = args[2];\n\t\tdynargs[3] = args[3];\n\t\tdynargs[4] = args[4];\n\t\treturn oraclize_query(datasource, dynargs);\n\t}\n\tfunction oraclize_query(uint timestamp, string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\n\t\tbytes[] memory dynargs = new bytes[](5);\n\t\tdynargs[0] = args[0];\n\t\tdynargs[1] = args[1];\n\t\tdynargs[2] = args[2];\n\t\tdynargs[3] = args[3];\n\t\tdynargs[4] = args[4];\n\t\treturn oraclize_query(timestamp, datasource, dynargs);\n\t}\n\tfunction oraclize_query(uint timestamp, string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\t\tbytes[] memory dynargs = new bytes[](5);\n\t\tdynargs[0] = args[0];\n\t\tdynargs[1] = args[1];\n\t\tdynargs[2] = args[2];\n\t\tdynargs[3] = args[3];\n\t\tdynargs[4] = args[4];\n\t\treturn oraclize_query(timestamp, datasource, dynargs, gaslimit);\n\t}\n\tfunction oraclize_query(string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\t\tbytes[] memory dynargs = new bytes[](5);\n\t\tdynargs[0] = args[0];\n\t\tdynargs[1] = args[1];\n\t\tdynargs[2] = args[2];\n\t\tdynargs[3] = args[3];\n\t\tdynargs[4] = args[4];\n\t\treturn oraclize_query(datasource, dynargs, gaslimit);\n\t}\n\n\tfunction oraclize_cbAddress() oraclizeAPI internal returns (address){\n\t\treturn oraclize.cbAddress();\n\t}\n\tfunction oraclize_setProof(byte proofP) oraclizeAPI internal {\n\t\treturn oraclize.setProofType(proofP);\n\t}\n\tfunction oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {\n\t\treturn oraclize.setCustomGasPrice(gasPrice);\n\t}\n\tfunction oraclize_setConfig(bytes32 config) oraclizeAPI internal {\n\t\treturn oraclize.setConfig(config);\n\t}\n\n\tfunction oraclize_randomDS_getSessionPubKeyHash() oraclizeAPI internal returns (bytes32){\n\t\treturn oraclize.randomDS_getSessionPubKeyHash();\n\t}\n\n\tfunction getCodeSize(address _addr) constant internal returns(uint _size) {\n\t\tassembly {\n\t\t_size := extcodesize(_addr)\n\t\t}\n\t}\n\n\tfunction parseAddr(string _a) internal returns (address){\n\t\tbytes memory tmp = bytes(_a);\n\t\tuint160 iaddr = 0;\n\t\tuint160 b1;\n\t\tuint160 b2;\n\t\tfor (uint i=2; i<2+2*20; i+=2){\n\t\t\tiaddr *= 256;\n\t\t\tb1 = uint160(tmp[i]);\n\t\t\tb2 = uint160(tmp[i+1]);\n\t\t\tif ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\n\t\t\telse if ((b1 >= 65)&&(b1 <= 70)) b1 -= 55;\n\t\t\telse if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n\t\t\tif ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\n\t\t\telse if ((b2 >= 65)&&(b2 <= 70)) b2 -= 55;\n\t\t\telse if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n\t\t\tiaddr += (b1*16+b2);\n\t\t}\n\t\treturn address(iaddr);\n\t}\n\n\tfunction strCompare(string _a, string _b) internal returns (int) {\n\t\tbytes memory a = bytes(_a);\n\t\tbytes memory b = bytes(_b);\n\t\tuint minLength = a.length;\n\t\tif (b.length < minLength) minLength = b.length;\n\t\tfor (uint i = 0; i < minLength; i ++)\n\t\tif (a[i] < b[i])\n\t\treturn -1;\n\t\telse if (a[i] > b[i])\n\t\treturn 1;\n\t\tif (a.length < b.length)\n\t\treturn -1;\n\t\telse if (a.length > b.length)\n\t\treturn 1;\n\t\telse\n\t\treturn 0;\n\t}\n\n\tfunction indexOf(string _haystack, string _needle) internal returns (int) {\n\t\tbytes memory h = bytes(_haystack);\n\t\tbytes memory n = bytes(_needle);\n\t\tif(h.length < 1 || n.length < 1 || (n.length > h.length))\n\t\treturn -1;\n\t\telse if(h.length > (2**128 -1))\n\t\treturn -1;\n\t\telse\n\t\t{\n\t\t\tuint subindex = 0;\n\t\t\tfor (uint i = 0; i < h.length; i ++)\n\t\t\t{\n\t\t\t\tif (h[i] == n[0])\n\t\t\t\t{\n\t\t\t\t\tsubindex = 1;\n\t\t\t\t\twhile(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n\t\t\t\t\t{\n\t\t\t\t\t\tsubindex++;\n\t\t\t\t\t}\n\t\t\t\t\tif(subindex == n.length)\n\t\t\t\t\treturn int(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tfunction strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string) {\n\t\tbytes memory _ba = bytes(_a);\n\t\tbytes memory _bb = bytes(_b);\n\t\tbytes memory _bc = bytes(_c);\n\t\tbytes memory _bd = bytes(_d);\n\t\tbytes memory _be = bytes(_e);\n\t\tstring memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n\t\tbytes memory babcde = bytes(abcde);\n\t\tuint k = 0;\n\t\tfor (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n\t\tfor (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n\t\tfor (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n\t\tfor (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n\t\tfor (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n\t\treturn string(babcde);\n\t}\n\n\tfunction strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\n\t\treturn strConcat(_a, _b, _c, _d, \"\");\n\t}\n\n\tfunction strConcat(string _a, string _b, string _c) internal returns (string) {\n\t\treturn strConcat(_a, _b, _c, \"\", \"\");\n\t}\n\n\tfunction strConcat(string _a, string _b) internal returns (string) {\n\t\treturn strConcat(_a, _b, \"\", \"\", \"\");\n\t}\n\n\t// parseInt\n\tfunction parseInt(string _a) internal returns (uint) {\n\t\treturn parseInt(_a, 0);\n\t}\n\n\t// parseInt(parseFloat*10^_b)\n\tfunction parseInt(string _a, uint _b) internal returns (uint) {\n\t\tbytes memory bresult = bytes(_a);\n\t\tuint mint = 0;\n\t\tbool decimals = false;\n\t\tfor (uint i=0; i<bresult.length; i++){\n\t\t\tif ((bresult[i] >= 48)&&(bresult[i] <= 57)){\n\t\t\t\tif (decimals){\n\t\t\t\t\tif (_b == 0) break;\n\t\t\t\t\telse _b--;\n\t\t\t\t}\n\t\t\t\tmint *= 10;\n\t\t\t\tmint += uint(bresult[i]) - 48;\n\t\t\t} else if (bresult[i] == 46) decimals = true;\n\t\t}\n\t\tif (_b > 0) mint *= 10**_b;\n\t\treturn mint;\n\t}\n\n\tfunction uint2str(uint i) internal returns (string){\n\t\tif (i == 0) return \"0\";\n\t\tuint j = i;\n\t\tuint len;\n\t\twhile (j != 0){\n\t\t\tlen++;\n\t\t\tj /= 10;\n\t\t}\n\t\tbytes memory bstr = new bytes(len);\n\t\tuint k = len - 1;\n\t\twhile (i != 0){\n\t\t\tbstr[k--] = byte(48 + i % 10);\n\t\t\ti /= 10;\n\t\t}\n\t\treturn string(bstr);\n\t}\n\n\tfunction stra2cbor(string[] arr) internal returns (bytes) {\n\t\tuint arrlen = arr.length;\n\n\t\t// get correct cbor output length\n\t\tuint outputlen = 0;\n\t\tbytes[] memory elemArray = new bytes[](arrlen);\n\t\tfor (uint i = 0; i < arrlen; i++) {\n\t\t\telemArray[i] = (bytes(arr[i]));\n\t\t\toutputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3; //+3 accounts for paired identifier types\n\t\t}\n\t\tuint ctr = 0;\n\t\tuint cborlen = arrlen + 0x80;\n\t\toutputlen += byte(cborlen).length;\n\t\tbytes memory res = new bytes(outputlen);\n\n\t\twhile (byte(cborlen).length > ctr) {\n\t\t\tres[ctr] = byte(cborlen)[ctr];\n\t\t\tctr++;\n\t\t}\n\t\tfor (i = 0; i < arrlen; i++) {\n\t\t\tres[ctr] = 0x5F;\n\t\t\tctr++;\n\t\t\tfor (uint x = 0; x < elemArray[i].length; x++) {\n\t\t\t\t// if there's a bug with larger strings, this may be the culprit\n\t\t\t\tif (x % 23 == 0) {\n\t\t\t\t\tuint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x;\n\t\t\t\t\telemcborlen += 0x40;\n\t\t\t\t\tuint lctr = ctr;\n\t\t\t\t\twhile (byte(elemcborlen).length > ctr - lctr) {\n\t\t\t\t\t\tres[ctr] = byte(elemcborlen)[ctr - lctr];\n\t\t\t\t\t\tctr++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tres[ctr] = elemArray[i][x];\n\t\t\t\tctr++;\n\t\t\t}\n\t\t\tres[ctr] = 0xFF;\n\t\t\tctr++;\n\t\t}\n\t\treturn res;\n\t}\n\n\tfunction ba2cbor(bytes[] arr) internal returns (bytes) {\n\t\tuint arrlen = arr.length;\n\n\t\t// get correct cbor output length\n\t\tuint outputlen = 0;\n\t\tbytes[] memory elemArray = new bytes[](arrlen);\n\t\tfor (uint i = 0; i < arrlen; i++) {\n\t\t\telemArray[i] = (bytes(arr[i]));\n\t\t\toutputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3; //+3 accounts for paired identifier types\n\t\t}\n\t\tuint ctr = 0;\n\t\tuint cborlen = arrlen + 0x80;\n\t\toutputlen += byte(cborlen).length;\n\t\tbytes memory res = new bytes(outputlen);\n\n\t\twhile (byte(cborlen).length > ctr) {\n\t\t\tres[ctr] = byte(cborlen)[ctr];\n\t\t\tctr++;\n\t\t}\n\t\tfor (i = 0; i < arrlen; i++) {\n\t\t\tres[ctr] = 0x5F;\n\t\t\tctr++;\n\t\t\tfor (uint x = 0; x < elemArray[i].length; x++) {\n\t\t\t\t// if there's a bug with larger strings, this may be the culprit\n\t\t\t\tif (x % 23 == 0) {\n\t\t\t\t\tuint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x;\n\t\t\t\t\telemcborlen += 0x40;\n\t\t\t\t\tuint lctr = ctr;\n\t\t\t\t\twhile (byte(elemcborlen).length > ctr - lctr) {\n\t\t\t\t\t\tres[ctr] = byte(elemcborlen)[ctr - lctr];\n\t\t\t\t\t\tctr++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tres[ctr] = elemArray[i][x];\n\t\t\t\tctr++;\n\t\t\t}\n\t\t\tres[ctr] = 0xFF;\n\t\t\tctr++;\n\t\t}\n\t\treturn res;\n\t}\n\n\n\tstring oraclize_network_name;\n\tfunction oraclize_setNetworkName(string _network_name) internal {\n\t\toraclize_network_name = _network_name;\n\t}\n\n\tfunction oraclize_getNetworkName() internal returns (string) {\n\t\treturn oraclize_network_name;\n\t}\n\n\tfunction oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){\n\t\tif ((_nbytes == 0)||(_nbytes > 32)) throw;\n\t\tbytes memory nbytes = new bytes(1);\n\t\tnbytes[0] = byte(_nbytes);\n\t\tbytes memory unonce = new bytes(32);\n\t\tbytes memory sessionKeyHash = new bytes(32);\n\t\tbytes32 sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash();\n\t\tassembly {\n\t\tmstore(unonce, 0x20)\n\t\tmstore(add(unonce, 0x20), xor(blockhash(sub(number, 1)), xor(coinbase, timestamp)))\n\t\tmstore(sessionKeyHash, 0x20)\n\t\tmstore(add(sessionKeyHash, 0x20), sessionKeyHash_bytes32)\n\t\t}\n\t\tbytes[3] memory args = [unonce, nbytes, sessionKeyHash];\n\t\tbytes32 queryId = oraclize_query(_delay, \"random\", args, _customGasLimit);\n\t\toraclize_randomDS_setCommitment(queryId, sha3(bytes8(_delay), args[1], sha256(args[0]), args[2]));\n\t\treturn queryId;\n\t}\n\n\tfunction oraclize_randomDS_setCommitment(bytes32 queryId, bytes32 commitment) internal {\n\t\toraclize_randomDS_args[queryId] = commitment;\n\t}\n\n\tmapping(bytes32=>bytes32) oraclize_randomDS_args;\n\tmapping(bytes32=>bool) oraclize_randomDS_sessionKeysHashVerified;\n\n\tfunction verifySig(bytes32 tosignh, bytes dersig, bytes pubkey) internal returns (bool){\n\t\tbool sigok;\n\t\taddress signer;\n\n\t\tbytes32 sigr;\n\t\tbytes32 sigs;\n\n\t\tbytes memory sigr_ = new bytes(32);\n\t\tuint offset = 4+(uint(dersig[3]) - 0x20);\n\t\tsigr_ = copyBytes(dersig, offset, 32, sigr_, 0);\n\t\tbytes memory sigs_ = new bytes(32);\n\t\toffset += 32 + 2;\n\t\tsigs_ = copyBytes(dersig, offset+(uint(dersig[offset-1]) - 0x20), 32, sigs_, 0);\n\n\t\tassembly {\n\t\tsigr := mload(add(sigr_, 32))\n\t\tsigs := mload(add(sigs_, 32))\n\t\t}\n\n\n\t\t(sigok, signer) = safer_ecrecover(tosignh, 27, sigr, sigs);\n\t\tif (address(sha3(pubkey)) == signer) return true;\n\t\telse {\n\t\t\t(sigok, signer) = safer_ecrecover(tosignh, 28, sigr, sigs);\n\t\t\treturn (address(sha3(pubkey)) == signer);\n\t\t}\n\t}\n\n\tfunction oraclize_randomDS_proofVerify__sessionKeyValidity(bytes proof, uint sig2offset) internal returns (bool) {\n\t\tbool sigok;\n\n\t\t// Step 6: verify the attestation signature, APPKEY1 must sign the sessionKey from the correct ledger app (CODEHASH)\n\t\tbytes memory sig2 = new bytes(uint(proof[sig2offset+1])+2);\n\t\tcopyBytes(proof, sig2offset, sig2.length, sig2, 0);\n\n\t\tbytes memory appkey1_pubkey = new bytes(64);\n\t\tcopyBytes(proof, 3+1, 64, appkey1_pubkey, 0);\n\n\t\tbytes memory tosign2 = new bytes(1+65+32);\n\t\ttosign2[0] = 1; //role\n\t\tcopyBytes(proof, sig2offset-65, 65, tosign2, 1);\n\t\tbytes memory CODEHASH = hex\"fd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c\";\n\t\tcopyBytes(CODEHASH, 0, 32, tosign2, 1+65);\n\t\tsigok = verifySig(sha256(tosign2), sig2, appkey1_pubkey);\n\n\t\tif (sigok == false) return false;\n\n\n\t\t// Step 7: verify the APPKEY1 provenance (must be signed by Ledger)\n\t\tbytes memory LEDGERKEY = hex\"7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4\";\n\n\t\tbytes memory tosign3 = new bytes(1+65);\n\t\ttosign3[0] = 0xFE;\n\t\tcopyBytes(proof, 3, 65, tosign3, 1);\n\n\t\tbytes memory sig3 = new bytes(uint(proof[3+65+1])+2);\n\t\tcopyBytes(proof, 3+65, sig3.length, sig3, 0);\n\n\t\tsigok = verifySig(sha256(tosign3), sig3, LEDGERKEY);\n\n\t\treturn sigok;\n\t}\n\n\tmodifier oraclize_randomDS_proofVerify(bytes32 _queryId, string _result, bytes _proof) {\n\t\t// Step 1: the prefix has to match 'LP\\x01' (Ledger Proof version 1)\n\t\tif ((_proof[0] != \"L\")||(_proof[1] != \"P\")||(_proof[2] != 1)) throw;\n\n\t\tbool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\n\t\tif (proofVerified == false) throw;\n\n\t\t_;\n\t}\n\n\tfunction oraclize_randomDS_proofVerify__returnCode(bytes32 _queryId, string _result, bytes _proof) internal returns (uint8){\n\t\t// Step 1: the prefix has to match 'LP\\x01' (Ledger Proof version 1)\n\t\tif ((_proof[0] != \"L\")||(_proof[1] != \"P\")||(_proof[2] != 1)) return 1;\n\n\t\tbool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\n\t\tif (proofVerified == false) return 2;\n\n\t\treturn 0;\n\t}\n\n\tfunction matchBytes32Prefix(bytes32 content, bytes prefix, uint n_random_bytes) internal returns (bool){\n\t\tbool match_ = true;\n\n\t\tfor (uint256 i=0; i< n_random_bytes; i++) {\n\t\t\tif (content[i] != prefix[i]) match_ = false;\n\t\t}\n\n\t\treturn match_;\n\t}\n\n\tfunction oraclize_randomDS_proofVerify__main(bytes proof, bytes32 queryId, bytes result, string context_name) internal returns (bool){\n\n\t\t// Step 2: the unique keyhash has to match with the sha256 of (context name + queryId)\n\t\tuint ledgerProofLength = 3+65+(uint(proof[3+65+1])+2)+32;\n\t\tbytes memory keyhash = new bytes(32);\n\t\tcopyBytes(proof, ledgerProofLength, 32, keyhash, 0);\n\t\tif (!(sha3(keyhash) == sha3(sha256(context_name, queryId)))) return false;\n\n\t\tbytes memory sig1 = new bytes(uint(proof[ledgerProofLength+(32+8+1+32)+1])+2);\n\t\tcopyBytes(proof, ledgerProofLength+(32+8+1+32), sig1.length, sig1, 0);\n\n\t\t// Step 3: we assume sig1 is valid (it will be verified during step 5) and we verify if 'result' is the prefix of sha256(sig1)\n\t\tif (!matchBytes32Prefix(sha256(sig1), result, uint(proof[ledgerProofLength+32+8]))) return false;\n\n\t\t// Step 4: commitment match verification, sha3(delay, nbytes, unonce, sessionKeyHash) == commitment in storage.\n\t\t// This is to verify that the computed args match with the ones specified in the query.\n\t\tbytes memory commitmentSlice1 = new bytes(8+1+32);\n\t\tcopyBytes(proof, ledgerProofLength+32, 8+1+32, commitmentSlice1, 0);\n\n\t\tbytes memory sessionPubkey = new bytes(64);\n\t\tuint sig2offset = ledgerProofLength+32+(8+1+32)+sig1.length+65;\n\t\tcopyBytes(proof, sig2offset-64, 64, sessionPubkey, 0);\n\n\t\tbytes32 sessionPubkeyHash = sha256(sessionPubkey);\n\t\tif (oraclize_randomDS_args[queryId] == sha3(commitmentSlice1, sessionPubkeyHash)){ //unonce, nbytes and sessionKeyHash match\n\t\t\tdelete oraclize_randomDS_args[queryId];\n\t\t} else return false;\n\n\n\t\t// Step 5: validity verification for sig1 (keyhash and args signed with the sessionKey)\n\t\tbytes memory tosign1 = new bytes(32+8+1+32);\n\t\tcopyBytes(proof, ledgerProofLength, 32+8+1+32, tosign1, 0);\n\t\tif (!verifySig(sha256(tosign1), sig1, sessionPubkey)) return false;\n\n\t\t// verify if sessionPubkeyHash was verified already, if not.. let's do it!\n\t\tif (oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] == false){\n\t\t\toraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] = oraclize_randomDS_proofVerify__sessionKeyValidity(proof, sig2offset);\n\t\t}\n\n\t\treturn oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash];\n\t}\n\n\n\t// the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license\n\tfunction copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal returns (bytes) {\n\t\tuint minLength = length + toOffset;\n\n\t\tif (to.length < minLength) {\n\t\t\t// Buffer too small\n\t\t\tthrow; // Should be a better way?\n\t\t}\n\n\t\t// NOTE: the offset 32 is added to skip the `size` field of both bytes variables\n\t\tuint i = 32 + fromOffset;\n\t\tuint j = 32 + toOffset;\n\n\t\twhile (i < (32 + fromOffset + length)) {\n\t\t\tassembly {\n\t\t\tlet tmp := mload(add(from, i))\n\t\t\tmstore(add(to, j), tmp)\n\t\t\t}\n\t\t\ti += 32;\n\t\t\tj += 32;\n\t\t}\n\n\t\treturn to;\n\t}\n\n\t// the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license\n\t// Duplicate Solidity's ecrecover, but catching the CALL return value\n\tfunction safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {\n\t\t// We do our own memory management here. Solidity uses memory offset\n\t\t// 0x40 to store the current end of memory. We write past it (as\n\t\t// writes are memory extensions), but don't update the offset so\n\t\t// Solidity will reuse it. The memory used here is only needed for\n\t\t// this context.\n\n\t\t// FIXME: inline assembly can't access return values\n\t\tbool ret;\n\t\taddress addr;\n\n\t\tassembly {\n\t\tlet size := mload(0x40)\n\t\tmstore(size, hash)\n\t\tmstore(add(size, 32), v)\n\t\tmstore(add(size, 64), r)\n\t\tmstore(add(size, 96), s)\n\n\t\t// NOTE: we can reuse the request memory because we deal with\n\t\t//       the return code\n\t\tret := call(3000, 1, 0, size, 128, size, 32)\n\t\taddr := mload(size)\n\t\t}\n\n\t\treturn (ret, addr);\n\t}\n\n\t// the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license\n\tfunction ecrecovery(bytes32 hash, bytes sig) internal returns (bool, address) {\n\t\tbytes32 r;\n\t\tbytes32 s;\n\t\tuint8 v;\n\n\t\tif (sig.length != 65)\n\t\treturn (false, 0);\n\n\t\t// The signature format is a compact form of:\n\t\t//   {bytes32 r}{bytes32 s}{uint8 v}\n\t\t// Compact means, uint8 is not padded to 32 bytes.\n\t\tassembly {\n\t\tr := mload(add(sig, 32))\n\t\ts := mload(add(sig, 64))\n\n\t\t// Here we are loading the last 32 bytes. We exploit the fact that\n\t\t// 'mload' will pad with zeroes if we overread.\n\t\t// There is no 'mload8' to do this, but that would be nicer.\n\t\tv := byte(0, mload(add(sig, 96)))\n\n\t\t// Alternative solution:\n\t\t// 'byte' is not working due to the Solidity parser, so lets\n\t\t// use the second best option, 'and'\n\t\t// v := and(mload(add(sig, 65)), 255)\n\t}\n\n// albeit non-transactional signatures are not specified by the YP, one would expect it\n// to match the YP range of [27, 28]\n//\n// geth uses [0, 1] and some clients have followed. This might change, see:\n//  https://github.com/ethereum/go-ethereum/issues/2053\nif (v < 27)\nv += 27;\n\nif (v != 27 && v != 28)\nreturn (false, 0);\n\nreturn safer_ecrecover(hash, v, r, s);\n}\n\n}\n// </ORACLIZE_API>\n\n","abiDocs":[{"constant":false,"inputs":[{"name":"myid","type":"bytes32"},{"name":"result","type":"string"}],"name":"__callback","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","signature":"__callback(bytes32,string)","signatureHash":"27dc297e"},{"constant":false,"inputs":[{"name":"myid","type":"bytes32"},{"name":"result","type":"string"},{"name":"proof","type":"bytes"}],"name":"__callback","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","signature":"__callback(bytes32,string,bytes)","signatureHash":"38bbfa50"}]}
